/*
 * VMaaS Webapp
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 2.27.2
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package vmaas

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiVmaasWebappAppCVEHandlerGetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	cve string
}


func (r ApiVmaasWebappAppCVEHandlerGetGetRequest) Execute() (CvesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppCVEHandlerGetGetExecute(r)
}

/*
 * VmaasWebappAppCVEHandlerGetGet Method for VmaasWebappAppCVEHandlerGetGet
 * Get details about CVEs. It is possible to use POSIX regular expression as a pattern for CVE names.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param cve CVE name or POSIX regular expression pattern
 * @return ApiVmaasWebappAppCVEHandlerGetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppCVEHandlerGetGet(ctx _context.Context, cve string) ApiVmaasWebappAppCVEHandlerGetGetRequest {
	return ApiVmaasWebappAppCVEHandlerGetGetRequest{
		ApiService: a,
		ctx: ctx,
		cve: cve,
	}
}

/*
 * Execute executes the request
 * @return CvesResponse
 */
func (a *DefaultApiService) VmaasWebappAppCVEHandlerGetGetExecute(r ApiVmaasWebappAppCVEHandlerGetGetRequest) (CvesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CvesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppCVEHandlerGetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cves/{cve}"
	localVarPath = strings.Replace(localVarPath, "{"+"cve"+"}", _neturl.PathEscape(parameterToString(r.cve, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppCVEHandlerPostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	cvesRequest *CvesRequest
}

func (r ApiVmaasWebappAppCVEHandlerPostPostRequest) CvesRequest(cvesRequest CvesRequest) ApiVmaasWebappAppCVEHandlerPostPostRequest {
	r.cvesRequest = &cvesRequest
	return r
}

func (r ApiVmaasWebappAppCVEHandlerPostPostRequest) Execute() (CvesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppCVEHandlerPostPostExecute(r)
}

/*
 * VmaasWebappAppCVEHandlerPostPost Method for VmaasWebappAppCVEHandlerPostPost
 * Get details about CVEs with additional parameters. As a "cve_list" parameter a complete list of CVE names can be provided OR one POSIX regular expression.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppCVEHandlerPostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppCVEHandlerPostPost(ctx _context.Context) ApiVmaasWebappAppCVEHandlerPostPostRequest {
	return ApiVmaasWebappAppCVEHandlerPostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return CvesResponse
 */
func (a *DefaultApiService) VmaasWebappAppCVEHandlerPostPostExecute(r ApiVmaasWebappAppCVEHandlerPostPostRequest) (CvesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CvesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppCVEHandlerPostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/cves"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cvesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppDBChangeHandlerGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
}


func (r ApiVmaasWebappAppDBChangeHandlerGetRequest) Execute() (DBChangeResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppDBChangeHandlerGetExecute(r)
}

/*
 * VmaasWebappAppDBChangeHandlerGet Method for VmaasWebappAppDBChangeHandlerGet
 * Get last-updated-times for VMaaS DB
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppDBChangeHandlerGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppDBChangeHandlerGet(ctx _context.Context) ApiVmaasWebappAppDBChangeHandlerGetRequest {
	return ApiVmaasWebappAppDBChangeHandlerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return DBChangeResponse
 */
func (a *DefaultApiService) VmaasWebappAppDBChangeHandlerGetExecute(r ApiVmaasWebappAppDBChangeHandlerGetRequest) (DBChangeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DBChangeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppDBChangeHandlerGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/dbchange"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppErrataHandlerGetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	erratum string
}


func (r ApiVmaasWebappAppErrataHandlerGetGetRequest) Execute() (ErrataResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppErrataHandlerGetGetExecute(r)
}

/*
 * VmaasWebappAppErrataHandlerGetGet Method for VmaasWebappAppErrataHandlerGetGet
 * Get details about errata. It is possible to use POSIX regular expression as a pattern for errata names.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param erratum Errata advisory name or POSIX regular expression pattern
 * @return ApiVmaasWebappAppErrataHandlerGetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppErrataHandlerGetGet(ctx _context.Context, erratum string) ApiVmaasWebappAppErrataHandlerGetGetRequest {
	return ApiVmaasWebappAppErrataHandlerGetGetRequest{
		ApiService: a,
		ctx: ctx,
		erratum: erratum,
	}
}

/*
 * Execute executes the request
 * @return ErrataResponse
 */
func (a *DefaultApiService) VmaasWebappAppErrataHandlerGetGetExecute(r ApiVmaasWebappAppErrataHandlerGetGetRequest) (ErrataResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ErrataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppErrataHandlerGetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/errata/{erratum}"
	localVarPath = strings.Replace(localVarPath, "{"+"erratum"+"}", _neturl.PathEscape(parameterToString(r.erratum, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppErrataHandlerPostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	errataRequest *ErrataRequest
}

func (r ApiVmaasWebappAppErrataHandlerPostPostRequest) ErrataRequest(errataRequest ErrataRequest) ApiVmaasWebappAppErrataHandlerPostPostRequest {
	r.errataRequest = &errataRequest
	return r
}

func (r ApiVmaasWebappAppErrataHandlerPostPostRequest) Execute() (ErrataResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppErrataHandlerPostPostExecute(r)
}

/*
 * VmaasWebappAppErrataHandlerPostPost Method for VmaasWebappAppErrataHandlerPostPost
 * Get details about errata with additional parameters. "errata_list" parameter can be either a list of errata names OR a single POSIX regular expression.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppErrataHandlerPostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppErrataHandlerPostPost(ctx _context.Context) ApiVmaasWebappAppErrataHandlerPostPostRequest {
	return ApiVmaasWebappAppErrataHandlerPostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ErrataResponse
 */
func (a *DefaultApiService) VmaasWebappAppErrataHandlerPostPostExecute(r ApiVmaasWebappAppErrataHandlerPostPostRequest) (ErrataResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ErrataResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppErrataHandlerPostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/errata"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errataRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppHealthHandlerGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
}


func (r ApiVmaasWebappAppHealthHandlerGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppHealthHandlerGetExecute(r)
}

/*
 * VmaasWebappAppHealthHandlerGet Return API liveness status
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppHealthHandlerGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppHealthHandlerGet(ctx _context.Context) ApiVmaasWebappAppHealthHandlerGetRequest {
	return ApiVmaasWebappAppHealthHandlerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) VmaasWebappAppHealthHandlerGetExecute(r ApiVmaasWebappAppHealthHandlerGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppHealthHandlerGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitoring/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVmaasWebappAppPackagesHandlerGetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	nevra string
}


func (r ApiVmaasWebappAppPackagesHandlerGetGetRequest) Execute() (PackagesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppPackagesHandlerGetGetExecute(r)
}

/*
 * VmaasWebappAppPackagesHandlerGetGet Method for VmaasWebappAppPackagesHandlerGetGet
 * Get details about packages.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nevra Package NEVRA
 * @return ApiVmaasWebappAppPackagesHandlerGetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppPackagesHandlerGetGet(ctx _context.Context, nevra string) ApiVmaasWebappAppPackagesHandlerGetGetRequest {
	return ApiVmaasWebappAppPackagesHandlerGetGetRequest{
		ApiService: a,
		ctx: ctx,
		nevra: nevra,
	}
}

/*
 * Execute executes the request
 * @return PackagesResponse
 */
func (a *DefaultApiService) VmaasWebappAppPackagesHandlerGetGetExecute(r ApiVmaasWebappAppPackagesHandlerGetGetRequest) (PackagesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PackagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppPackagesHandlerGetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packages/{nevra}"
	localVarPath = strings.Replace(localVarPath, "{"+"nevra"+"}", _neturl.PathEscape(parameterToString(r.nevra, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppPackagesHandlerPostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	packagesRequest *PackagesRequest
}

func (r ApiVmaasWebappAppPackagesHandlerPostPostRequest) PackagesRequest(packagesRequest PackagesRequest) ApiVmaasWebappAppPackagesHandlerPostPostRequest {
	r.packagesRequest = &packagesRequest
	return r
}

func (r ApiVmaasWebappAppPackagesHandlerPostPostRequest) Execute() (PackagesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppPackagesHandlerPostPostExecute(r)
}

/*
 * VmaasWebappAppPackagesHandlerPostPost Method for VmaasWebappAppPackagesHandlerPostPost
 * Get details about packages. "package_list" must be a list of package NEVRAs.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppPackagesHandlerPostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppPackagesHandlerPostPost(ctx _context.Context) ApiVmaasWebappAppPackagesHandlerPostPostRequest {
	return ApiVmaasWebappAppPackagesHandlerPostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PackagesResponse
 */
func (a *DefaultApiService) VmaasWebappAppPackagesHandlerPostPostExecute(r ApiVmaasWebappAppPackagesHandlerPostPostRequest) (PackagesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PackagesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppPackagesHandlerPostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/packages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.packagesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppPatchesHandlerGetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	nevra string
}


func (r ApiVmaasWebappAppPatchesHandlerGetGetRequest) Execute() (PatchesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppPatchesHandlerGetGetExecute(r)
}

/*
 * VmaasWebappAppPatchesHandlerGetGet Method for VmaasWebappAppPatchesHandlerGetGet
 * List of applicable CVEs for a single package NEVRA
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nevra Package NEVRA
 * @return ApiVmaasWebappAppPatchesHandlerGetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppPatchesHandlerGetGet(ctx _context.Context, nevra string) ApiVmaasWebappAppPatchesHandlerGetGetRequest {
	return ApiVmaasWebappAppPatchesHandlerGetGetRequest{
		ApiService: a,
		ctx: ctx,
		nevra: nevra,
	}
}

/*
 * Execute executes the request
 * @return PatchesResponse
 */
func (a *DefaultApiService) VmaasWebappAppPatchesHandlerGetGetExecute(r ApiVmaasWebappAppPatchesHandlerGetGetRequest) (PatchesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PatchesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppPatchesHandlerGetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patches/{nevra}"
	localVarPath = strings.Replace(localVarPath, "{"+"nevra"+"}", _neturl.PathEscape(parameterToString(r.nevra, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppPatchesHandlerPostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	patchesRequest *PatchesRequest
}

func (r ApiVmaasWebappAppPatchesHandlerPostPostRequest) PatchesRequest(patchesRequest PatchesRequest) ApiVmaasWebappAppPatchesHandlerPostPostRequest {
	r.patchesRequest = &patchesRequest
	return r
}

func (r ApiVmaasWebappAppPatchesHandlerPostPostRequest) Execute() (PatchesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppPatchesHandlerPostPostExecute(r)
}

/*
 * VmaasWebappAppPatchesHandlerPostPost Method for VmaasWebappAppPatchesHandlerPostPost
 * List of applicable errata to a package list.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppPatchesHandlerPostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppPatchesHandlerPostPost(ctx _context.Context) ApiVmaasWebappAppPatchesHandlerPostPostRequest {
	return ApiVmaasWebappAppPatchesHandlerPostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PatchesResponse
 */
func (a *DefaultApiService) VmaasWebappAppPatchesHandlerPostPostExecute(r ApiVmaasWebappAppPatchesHandlerPostPostRequest) (PatchesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PatchesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppPatchesHandlerPostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/patches"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppPkgtreeHandlerV3GetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	packageName string
}


func (r ApiVmaasWebappAppPkgtreeHandlerV3GetGetRequest) Execute() (PkgtreeResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppPkgtreeHandlerV3GetGetExecute(r)
}

/*
 * VmaasWebappAppPkgtreeHandlerV3GetGet Method for VmaasWebappAppPkgtreeHandlerV3GetGet
 * Get package NEVRAs tree for a single package name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param packageName Package name
 * @return ApiVmaasWebappAppPkgtreeHandlerV3GetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppPkgtreeHandlerV3GetGet(ctx _context.Context, packageName string) ApiVmaasWebappAppPkgtreeHandlerV3GetGetRequest {
	return ApiVmaasWebappAppPkgtreeHandlerV3GetGetRequest{
		ApiService: a,
		ctx: ctx,
		packageName: packageName,
	}
}

/*
 * Execute executes the request
 * @return PkgtreeResponse
 */
func (a *DefaultApiService) VmaasWebappAppPkgtreeHandlerV3GetGetExecute(r ApiVmaasWebappAppPkgtreeHandlerV3GetGetRequest) (PkgtreeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PkgtreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppPkgtreeHandlerV3GetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pkgtree/{package_name}"
	localVarPath = strings.Replace(localVarPath, "{"+"package_name"+"}", _neturl.PathEscape(parameterToString(r.packageName, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	pkgtreeRequest *PkgtreeRequest
}

func (r ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest) PkgtreeRequest(pkgtreeRequest PkgtreeRequest) ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest {
	r.pkgtreeRequest = &pkgtreeRequest
	return r
}

func (r ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest) Execute() (PkgtreeResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppPkgtreeHandlerV3PostPostExecute(r)
}

/*
 * VmaasWebappAppPkgtreeHandlerV3PostPost Method for VmaasWebappAppPkgtreeHandlerV3PostPost
 * Get package NEVRAs trees for package names. "package_name_list" must be a list of package names OR one POSIX regular expression.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppPkgtreeHandlerV3PostPost(ctx _context.Context) ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest {
	return ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return PkgtreeResponse
 */
func (a *DefaultApiService) VmaasWebappAppPkgtreeHandlerV3PostPostExecute(r ApiVmaasWebappAppPkgtreeHandlerV3PostPostRequest) (PkgtreeResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  PkgtreeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppPkgtreeHandlerV3PostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/pkgtree"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pkgtreeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppReadyHandlerGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
}


func (r ApiVmaasWebappAppReadyHandlerGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppReadyHandlerGetExecute(r)
}

/*
 * VmaasWebappAppReadyHandlerGet Return API readiness status
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppReadyHandlerGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppReadyHandlerGet(ctx _context.Context) ApiVmaasWebappAppReadyHandlerGetRequest {
	return ApiVmaasWebappAppReadyHandlerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) VmaasWebappAppReadyHandlerGetExecute(r ApiVmaasWebappAppReadyHandlerGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppReadyHandlerGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/monitoring/ready"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVmaasWebappAppReposHandlerGetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	repo string
}


func (r ApiVmaasWebappAppReposHandlerGetGetRequest) Execute() (ReposResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppReposHandlerGetGetExecute(r)
}

/*
 * VmaasWebappAppReposHandlerGetGet Method for VmaasWebappAppReposHandlerGetGet
 * Get details about a repository or repository-expression. It is allowed to use POSIX regular expression as a pattern for repository names.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repo Repository name or POSIX regular expression pattern
 * @return ApiVmaasWebappAppReposHandlerGetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppReposHandlerGetGet(ctx _context.Context, repo string) ApiVmaasWebappAppReposHandlerGetGetRequest {
	return ApiVmaasWebappAppReposHandlerGetGetRequest{
		ApiService: a,
		ctx: ctx,
		repo: repo,
	}
}

/*
 * Execute executes the request
 * @return ReposResponse
 */
func (a *DefaultApiService) VmaasWebappAppReposHandlerGetGetExecute(r ApiVmaasWebappAppReposHandlerGetGetRequest) (ReposResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReposResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppReposHandlerGetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos/{repo}"
	localVarPath = strings.Replace(localVarPath, "{"+"repo"+"}", _neturl.PathEscape(parameterToString(r.repo, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppReposHandlerPostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	reposRequest *ReposRequest
}

func (r ApiVmaasWebappAppReposHandlerPostPostRequest) ReposRequest(reposRequest ReposRequest) ApiVmaasWebappAppReposHandlerPostPostRequest {
	r.reposRequest = &reposRequest
	return r
}

func (r ApiVmaasWebappAppReposHandlerPostPostRequest) Execute() (ReposResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppReposHandlerPostPostExecute(r)
}

/*
 * VmaasWebappAppReposHandlerPostPost Method for VmaasWebappAppReposHandlerPostPost
 * Get details about list of repositories. "repository_list" can be either a list of repository names, OR a single POSIX regular expression.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppReposHandlerPostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppReposHandlerPostPost(ctx _context.Context) ApiVmaasWebappAppReposHandlerPostPostRequest {
	return ApiVmaasWebappAppReposHandlerPostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return ReposResponse
 */
func (a *DefaultApiService) VmaasWebappAppReposHandlerPostPostExecute(r ApiVmaasWebappAppReposHandlerPostPostRequest) (ReposResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ReposResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppReposHandlerPostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/repos"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.reposRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppUpdatesHandlerV3GetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	nevra string
}


func (r ApiVmaasWebappAppUpdatesHandlerV3GetGetRequest) Execute() (UpdatesV2Response, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppUpdatesHandlerV3GetGetExecute(r)
}

/*
 * VmaasWebappAppUpdatesHandlerV3GetGet Method for VmaasWebappAppUpdatesHandlerV3GetGet
 * List all updates for single package NEVRA
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nevra Package NEVRA
 * @return ApiVmaasWebappAppUpdatesHandlerV3GetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppUpdatesHandlerV3GetGet(ctx _context.Context, nevra string) ApiVmaasWebappAppUpdatesHandlerV3GetGetRequest {
	return ApiVmaasWebappAppUpdatesHandlerV3GetGetRequest{
		ApiService: a,
		ctx: ctx,
		nevra: nevra,
	}
}

/*
 * Execute executes the request
 * @return UpdatesV2Response
 */
func (a *DefaultApiService) VmaasWebappAppUpdatesHandlerV3GetGetExecute(r ApiVmaasWebappAppUpdatesHandlerV3GetGetRequest) (UpdatesV2Response, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdatesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppUpdatesHandlerV3GetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updates/{nevra}"
	localVarPath = strings.Replace(localVarPath, "{"+"nevra"+"}", _neturl.PathEscape(parameterToString(r.nevra, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	updatesV3Request *UpdatesV3Request
}

func (r ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest) UpdatesV3Request(updatesV3Request UpdatesV3Request) ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest {
	r.updatesV3Request = &updatesV3Request
	return r
}

func (r ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest) Execute() (UpdatesV2Response, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppUpdatesHandlerV3PostPostExecute(r)
}

/*
 * VmaasWebappAppUpdatesHandlerV3PostPost Method for VmaasWebappAppUpdatesHandlerV3PostPost
 * List all updates for list of package NEVRAs
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppUpdatesHandlerV3PostPost(ctx _context.Context) ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest {
	return ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return UpdatesV2Response
 */
func (a *DefaultApiService) VmaasWebappAppUpdatesHandlerV3PostPostExecute(r ApiVmaasWebappAppUpdatesHandlerV3PostPostRequest) (UpdatesV2Response, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdatesV2Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppUpdatesHandlerV3PostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/updates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updatesV3Request
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppVersionHandlerGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
}


func (r ApiVmaasWebappAppVersionHandlerGetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppVersionHandlerGetExecute(r)
}

/*
 * VmaasWebappAppVersionHandlerGet Method for VmaasWebappAppVersionHandlerGet
 * Get version of application
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppVersionHandlerGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppVersionHandlerGet(ctx _context.Context) ApiVmaasWebappAppVersionHandlerGetRequest {
	return ApiVmaasWebappAppVersionHandlerGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 */
func (a *DefaultApiService) VmaasWebappAppVersionHandlerGetExecute(r ApiVmaasWebappAppVersionHandlerGetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppVersionHandlerGet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/version"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiVmaasWebappAppVulnerabilitiesHandlerGetGetRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	nevra string
}


func (r ApiVmaasWebappAppVulnerabilitiesHandlerGetGetRequest) Execute() (VulnerabilitiesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppVulnerabilitiesHandlerGetGetExecute(r)
}

/*
 * VmaasWebappAppVulnerabilitiesHandlerGetGet Method for VmaasWebappAppVulnerabilitiesHandlerGetGet
 * List of applicable CVEs for a single package NEVRA
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param nevra Package NEVRA
 * @return ApiVmaasWebappAppVulnerabilitiesHandlerGetGetRequest
 */
func (a *DefaultApiService) VmaasWebappAppVulnerabilitiesHandlerGetGet(ctx _context.Context, nevra string) ApiVmaasWebappAppVulnerabilitiesHandlerGetGetRequest {
	return ApiVmaasWebappAppVulnerabilitiesHandlerGetGetRequest{
		ApiService: a,
		ctx: ctx,
		nevra: nevra,
	}
}

/*
 * Execute executes the request
 * @return VulnerabilitiesResponse
 */
func (a *DefaultApiService) VmaasWebappAppVulnerabilitiesHandlerGetGetExecute(r ApiVmaasWebappAppVulnerabilitiesHandlerGetGetRequest) (VulnerabilitiesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VulnerabilitiesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppVulnerabilitiesHandlerGetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vulnerabilities/{nevra}"
	localVarPath = strings.Replace(localVarPath, "{"+"nevra"+"}", _neturl.PathEscape(parameterToString(r.nevra, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest struct {
	ctx _context.Context
	ApiService *DefaultApiService
	vulnerabilitiesRequest *VulnerabilitiesRequest
}

func (r ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest) VulnerabilitiesRequest(vulnerabilitiesRequest VulnerabilitiesRequest) ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest {
	r.vulnerabilitiesRequest = &vulnerabilitiesRequest
	return r
}

func (r ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest) Execute() (VulnerabilitiesResponse, *_nethttp.Response, error) {
	return r.ApiService.VmaasWebappAppVulnerabilitiesHandlerPostPostExecute(r)
}

/*
 * VmaasWebappAppVulnerabilitiesHandlerPostPost Method for VmaasWebappAppVulnerabilitiesHandlerPostPost
 * List of applicable CVEs to a package list.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @return ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest
 */
func (a *DefaultApiService) VmaasWebappAppVulnerabilitiesHandlerPostPost(ctx _context.Context) ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest {
	return ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

/*
 * Execute executes the request
 * @return VulnerabilitiesResponse
 */
func (a *DefaultApiService) VmaasWebappAppVulnerabilitiesHandlerPostPostExecute(r ApiVmaasWebappAppVulnerabilitiesHandlerPostPostRequest) (VulnerabilitiesResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VulnerabilitiesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.VmaasWebappAppVulnerabilitiesHandlerPostPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/vulnerabilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.vulnerabilitiesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
